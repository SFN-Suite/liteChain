"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[237],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=i,d=u["".concat(s,".").concat(m)]||u[m]||h[m]||o;return n?a.createElement(d,r(r({ref:t},p),{},{components:n})):a.createElement(d,r({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1689:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:3},r="Working with Streams",l={unversionedId:"chain-basics/working_with_streams",id:"chain-basics/working_with_streams",title:"Working with Streams",description:"By default, all LLMs generate a stream of tokens:",source:"@site/docs/chain-basics/working_with_streams.md",sourceDirName:"chain-basics",slug:"/chain-basics/working_with_streams",permalink:"/litechain/docs/chain-basics/working_with_streams",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chain-basics/working_with_streams.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Why Streams?",permalink:"/litechain/docs/chain-basics/why_streams"},next:{title:"Composing Chains",permalink:"/litechain/docs/chain-basics/composing_chains"}},s={},c=[{value:"The whole Chain is streamed",id:"the-whole-chain-is-streamed",level:2},{value:"Output Utils",id:"output-utils",level:2}],p={toc:c},u="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"working-with-streams"},"Working with Streams"),(0,i.kt)("p",null,"By default, all LLMs generate a stream of tokens:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from litechain.contrib import OpenAICompletionChain\n\nbacon_chain = OpenAICompletionChain[str, str](\n    "BaconChain",\n    lambda input: input,\n    model="ada",\n)\n\nasync for output in bacon_chain("I like bacon and"):\n    print(output.data)\n#=> iced\n#=>  tea\n#=> .\n#=>  I\n#=>  like\n#=>  to\n#=>  eat\n#=>  bacon\n#=>  and\n#=>\n#=> iced\n#=>  tea\n#=> .\n')),(0,i.kt)("p",null,"You can notice that it will print more or less one word per line, those are the tokens it is generating, since Python by default adds a new line for each ",(0,i.kt)("inlineCode",{parentName:"p"},"print")," statement, we end up with one token per line."),(0,i.kt)("p",null,"When creating a simple Chain, if you return a single value, it will also output just that single value, so if you want to simulate an LLM, and create a chain that produces a stream of outputs, you can use the ",(0,i.kt)("a",{parentName:"p",href:"pathname:///reference/litechain/index.html#litechain.as_async_generator"},(0,i.kt)("inlineCode",{parentName:"a"},"as_async_generator()"))," utility function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from litechain import Chain, as_async_generator\n\nstream_of_bacon_chain = Chain[None, str](\n    "StreamOfBaconChain",\n    lambda _: as_async_generator("I", "like", "bacon"),\n)\n\nasync for output in stream_of_bacon_chain(None):\n    print(output.data)\n#=> I\n#=> like\n#=> bacon\n')),(0,i.kt)("h2",{id:"the-whole-chain-is-streamed"},"The whole Chain is streamed"),(0,i.kt)("p",null,"On LiteChain, when you compose two or more chains, map the results or apply any operations on it, still the original values of anything generating outputs anywhere in the chain gets streamed, this means that if you have a chain being mapped,\nboth the original output and the transformed ones will be outputted, for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from litechain import Chain, as_async_generator\n\nstream_of_bacon_chain = Chain[None, str](\n    "StreamOfBaconChain",\n    lambda _: as_async_generator("I", "like", "bacon"),\n)\n\ntell_the_world = stream_of_bacon_chain.map(lambda token: token.upper())\n\nasync for output in tell_the_world(None):\n    print(output.chain, ":", output.data)\n#=> StreamOfBaconChain : I\n#=> StreamOfBaconChain@map : I\n#=> StreamOfBaconChain : like\n#=> StreamOfBaconChain@map : LIKE\n#=> StreamOfBaconChain : bacon\n#=> StreamOfBaconChain@map : BACON\n')),(0,i.kt)("p",null,"This is done by design so that you can always inspect what is going in the middle of a complex chain, either to debug it, or to display to the user for a better user experience."),(0,i.kt)("p",null,"If you want just the final output, you can check for the property ",(0,i.kt)("a",{parentName:"p",href:"pathname:///reference/litechain/index.html#litechain.ChainOutput.final"},(0,i.kt)("inlineCode",{parentName:"a"},"output.final")),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import time\n\nasync for output in tell_the_world(None):\n    if output.final:\n        time.sleep(1) # added for dramatic effect\n        print(output.data)\n#=> I\n#=> LIKE\n#=> BACON\n")),(0,i.kt)("h2",{id:"output-utils"},"Output Utils"),(0,i.kt)("p",null,"Now, as shown on the examples, you need to iterate over it with ",(0,i.kt)("inlineCode",{parentName:"p"},"async for")," to get the final output. However, you might not care about streaming or inspecting the middle results at all, and just want the final result as a whole. For that, you can use some utility functions that LiteChain provides, for example, ",(0,i.kt)("a",{parentName:"p",href:"pathname:///reference/litechain/index.html#litechain.collect_final_output"},(0,i.kt)("inlineCode",{parentName:"a"},"collect_final_output()")),", which gives you a single list with the final outputs all at once:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from litechain import collect_final_output\n\nawait collect_final_output(tell_the_world(None))\n#=> ['I', 'LIKE', 'BACON']\n")),(0,i.kt)("p",null,"Or, if you chain's final output is ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),", then you can use ",(0,i.kt)("a",{parentName:"p",href:"pathname:///reference/litechain/index.html#litechain.join_final_output"},(0,i.kt)("inlineCode",{parentName:"a"},"join_final_output()")),", which gives you already the full string, concatenated"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from litechain import join_final_output\n\nawait join_final_output(tell_the_world(None))\n#=> 'ILIKEBACON'\n")),(0,i.kt)("p",null,"(LLMs produce spaces as token as well, so normally the lack of spaces in here is not a problem)"),(0,i.kt)("p",null,"Check out also ",(0,i.kt)("a",{parentName:"p",href:"pathname:///reference/litechain/index.html#litechain.filter_final_output"},(0,i.kt)("inlineCode",{parentName:"a"},"filter_final_output()")),", which gives you still an ",(0,i.kt)("inlineCode",{parentName:"p"},"AsyncGenerator")," to loop over, but including only the final results."),(0,i.kt)("p",null,"Now that you know all about streams, you need to understand what does that mean when you are composing them together, keep on reading to learn about Composing Chains."))}h.isMDXComponent=!0}}]);